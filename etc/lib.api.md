## API Report File for "@opennd/lib"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { default as default_2 } from 'exceljs';
import { default as default_3 } from 'short-uuid';
import { Request as Request_2 } from 'express';
import { Response as Response_2 } from 'express';

// @public (undocumented)
export type CreateOperate = 'arrayType' | 'plainType' | 'dateType' | 'relationQueryType';

// @public
export function excelCursorStream({ req, res, headers, sheetName, dataHeaderIndex, zlibLevel, merges, cursor, filename, width, }: ExcelStreamArs): Promise<void>;

// @public (undocumented)
export interface ExcelStreamArs {
    cursor: any;
    dataHeaderIndex?: number;
    filename: string;
    headers: Header[][];
    merges?: string[];
    req: Request_2;
    res: Response_2;
    // (undocumented)
    sheetName?: string;
    width?: number;
    zlibLevel?: number;
}

// @public (undocumented)
export type Filter = BooleanConstructor | StringConstructor | NumberConstructor | null;

// @public
export function func(): void;

// @public
export function getFirstNotUndefinedValue<T>(arr: any[]): T;

// @public
export function getPropByPath(obj: any, path: string, strict: any): {
    o: any;
    k: string;
    v: any;
};

// @public
export const getValueByPath: (object: any, prop: string) => any;

// @public (undocumented)
export interface Header {
    bgColor?: false | string;
    bold?: boolean;
    border?: boolean;
    dataIndex?: string;
    headerBgColor?: false | string;
    headerBold?: boolean;
    headerBorder?: boolean;
    headerHorizontal?: default_2.Alignment['horizontal'];
    headerSize?: number;
    headerVertical?: default_2.Alignment['vertical'];
    horizontal?: default_2.Alignment['horizontal'];
    renderCell?: <T>(data: T) => any;
    size?: number;
    title: string;
    vertical?: default_2.Alignment['vertical'];
    width?: number;
}

// @public
export function isArray(val: any): boolean;

// @public
export function isEmptyInput(val: any): boolean;

// @public
export function isEmptyObj(obj: any): boolean;

// @public
export function isNull(val: any): boolean;

// @public
export function isPlainObj(val: any): boolean;

// @public
export function isStr(val: any): val is string;

// @public
export function isUndef(val: any): boolean;

// @public
export function noInputEmptyInArr(arr: any): boolean;

// @public (undocumented)
export type Operate = 'arrayType' | 'plainType' | 'dateType' | 'relationManyQueryType' | 'relationQueryType';

// @public (undocumented)
export class PrismaCreateBuilder<T, TableFields = any> {
    constructor(source?: T, create?: Record<string, any>);
    arrayToString(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        join?: string;
        get?: string;
        idKey?: string;
        filter?: Filter;
    }): this;
    assign: <RelationTableFields extends Record<string, any> = Record<string, any>>(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        join?: string;
        get?: string;
        filter?: Filter;
        idKey?: keyof RelationTableFields;
        operate?: CreateOperate;
    }) => this;
    // (undocumented)
    create: () => any;
    relation: (key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        join?: string;
        get?: string;
        idKey?: string;
        filter?: Filter;
    }) => this;
    relationMany: <SourceType = any, RelationTableFields extends Record<string, any> = Record<string, any>>(params: {
        key: keyof T | Partial<Record<keyof T, keyof TableFields>>;
        filter?: Filter;
        idKey?: keyof RelationTableFields;
    }, cb?: (builder: InstanceType<typeof PrismaQueryBuilder<SourceType, RelationTableFields>>) => any) => this;
    // (undocumented)
    set: <RelationTableFields extends Record<string, any> = Record<string, any>>(params: {
        key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>;
        get?: string;
        filter?: Filter;
        join?: string;
        idKey?: keyof RelationTableFields;
        type: CreateOperate;
        builder?: (t: any) => any;
        cb: (query: any, k: string, val: any) => void;
    }) => this;
    time(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
    }): this;
}

// @public (undocumented)
export class PrismaQueryBuilder<T, TableFields = any> {
    constructor(source?: T, query?: Record<string, any>);
    ADD: (fn: (t: this) => void) => this;
    assign: <RelationTableFields extends Record<string, any> = Record<string, any>>(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        join?: string;
        get?: string;
        filter?: Filter;
        idKey?: keyof RelationTableFields;
        operate?: Operate;
    }) => this;
    contains: (key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        join?: string;
        get?: string;
        filter?: Filter;
    }) => this;
    equals: (key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        join?: string;
        get?: string;
        filter?: Filter;
    }) => this;
    in: (key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
        filter?: Filter;
        idKey?: string;
    }) => this;
    NOT: (fn: (t: this) => void) => this;
    notIn: (key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
        join?: string;
        idKey?: string;
        filter?: Filter;
    }) => this;
    OR: (fn: (t: this) => void) => this;
    query: () => any;
    relationAnd: <RelationTableFields extends Record<string, any> = Record<string, any>>(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
        idKey?: keyof RelationTableFields;
        filter?: Filter;
    }) => this;
    relationManyEvery: <SourceType = any, RelationTableFields extends Record<string, any> = Record<string, any>>(params: {
        key: keyof T | Partial<Record<keyof T, keyof TableFields>>;
        idKey?: keyof RelationTableFields;
    }, cb: (builder: InstanceType<typeof PrismaQueryBuilder<SourceType, RelationTableFields>>) => any) => this;
    relationManyNone: <SourceType = any, RelationTableFields extends Record<string, any> = Record<string, any>>(params: {
        key: keyof T | Partial<Record<keyof T, keyof TableFields>>;
        idKey?: keyof RelationTableFields;
    }, cb: (builder: InstanceType<typeof PrismaQueryBuilder<SourceType, RelationTableFields>>) => any) => this;
    relationManySome: <SourceType = any, RelationTableFields extends Record<string, any> = Record<string, any>>(params: {
        key: keyof T | Partial<Record<keyof T, keyof TableFields>>;
        idKey?: keyof RelationTableFields;
    }, cb: (builder: InstanceType<typeof PrismaQueryBuilder<SourceType, RelationTableFields>>) => any) => this;
    relationNot: <RelationTableFields extends Record<string, any> = Record<string, any>>(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
        idKey?: keyof RelationTableFields;
        filter?: Filter;
    }) => this;
    relationOr: <RelationTableFields extends Record<string, any> = Record<string, any>>(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
        idKey?: keyof RelationTableFields;
        filter?: Filter;
    }) => this;
    relationQuery: <SourceType = any, RelationTableFields extends Record<string, any> = Record<string, any>>(params: {
        key: keyof T | Partial<Record<keyof T, keyof TableFields>>;
        idKey?: keyof RelationTableFields;
    }, cb: (builder: InstanceType<typeof PrismaQueryBuilder<SourceType, RelationTableFields>>) => any) => this;
    // (undocumented)
    set: <RelationTableFields extends Record<string, any> = Record<string, any>>(params: {
        key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>;
        get?: string;
        filter?: Filter;
        join?: string;
        idKey?: keyof RelationTableFields;
        type: Operate;
        cb: (query: any, k: string, val: any) => void;
        builder?: (t: any) => any;
    }) => this;
    timeGte: (key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
    }) => this;
    timeLte: (key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params?: {
        get?: string;
    }) => this;
    timeRange: ({ startTimeField, endTimeField, to }: {
        startTimeField: keyof T;
        endTimeField: keyof T;
        to: keyof Omit<TableFields, "NOT" | "OR" | "AND">;
    }) => this;
}

// @public
export function realType(may: any): any;

// @public
export function realTypeEqual(may: any, type: string): boolean;

// @public
export function runFns(fns?: any[], args?: any[]): void;

// @public
export function setIfNotUndef(data: {}, key: string, value: any): void;

// @public
export function setValueByPath(obj: any, path: string, value: any): any;

// @public
export function sid(): default_3.SUUID;

// @public
export function undefinedAndNotNullValueAsTrue(val: string | any[]): boolean;

// @public
export function undefinedAndTrueAsTrue(val: boolean | any[]): boolean;

// (No @packageDocumentation comment for this package)

```
