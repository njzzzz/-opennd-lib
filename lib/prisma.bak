import { isEmptyInput, isPlainObj } from './utils'

export type GetPropType<T extends Record<string, any>, P extends string> = P extends `${infer L}.${infer R}` ? GetPropType<T[L], R> : T[P]
const FILTER_SPLIT = '|'
const PARAMS_SPLIT = ','
export class PrismaQueryBuilder<T extends Record<string, any> = Record<string, any>, K extends string = Extract<keyof T, string>> {
  query: Record<string, any> = {}
  source: Record<string, any> = {}
  constructor(source: Record<string, any> = {}, query: Record<string, any> = {}) {
    this.source = source
    this.query = query
    return this
  }

  /**
   * @description 核心函数
   */
  set = ({ keys = [], queryPipeline = [], filterPipeline = {} }: {
    keys: K | K[] | []
    queryPipeline: Pipeline[] | Pipeline
    // eslint-disable-next-line ts/ban-types
    filterPipeline?: Record<K, (filterPipeline | string & {})[] | filterPipeline> | object
  }) => {
    const { where = {} } = this.query
    const conditions = this.core<Pipeline>({ keys, queryPipeline, filterPipeline })
    // 处理参数
    this.query = {
      ...this.query,
      where: {
        ...where,
        ...conditions,
      },
    }
    return this
  }

  /**
   * @description 统一处理 filterPipeline Pipeline
   */
  core = <P extends string>({ keys = [], queryPipeline = [], filterPipeline = {} }: {
    keys: K | K[] | []
    queryPipeline: P[] | P
    // eslint-disable-next-line ts/ban-types
    filterPipeline?: Record<K, (filterPipeline | string & {})[] | filterPipeline> | object
  }) => {
    keys = typeof keys === 'string' ? [keys] : keys
    queryPipeline = typeof queryPipeline === 'string' ? [queryPipeline] : queryPipeline
    return keys.reduce((acc: Record<string, any>, key: string) => {
      const result = queryPipeline.reduce((data, operate) => {
        const filter = filterPipeline[key] ?? []
        const filters = typeof filter === 'string' ? [filter] : filter
        // 解析filter
        const filterFns = filters.map((filter = '') => {
          const [filterName, params = ''] = filter.split(FILTER_SPLIT)
          return (source: T, key: string) => {
            // 调用filter, 并传入参数
            return this[filterName](source, key, params.split(PARAMS_SPLIT))
          }
        })
        const result = filterFns.reduce((data, filter) => {
          // filter 传入的是从source取到的值
          return filter ? filter(data, key) : data
        }, this.source[key])
        data[operate] = result
        return data
      }, {} as any)
      // 处理重新赋值 reassign
      if (Reflect.has(result, 'reassign')) {
        acc[key] = result.reassign
      }
      else {
        acc[key] = result
      }
      return acc
    }, {})
  }

  /**
   *
   */
  reassign = ({
    key,
    filterPipeline,
  }: {
    key: K
    // eslint-disable-next-line ts/ban-types
    filterPipeline: (filterPipeline | string & {})[] | filterPipeline | string & {}
  }) => {
    this.set({
      keys: [key],
      queryPipeline: ['reassign'],
      filterPipeline: {
        [key]: filterPipeline,
      },
    })
    return this
  }

  /**
   * @description contains 快捷操作
   */
  contains = ({ keys = [], filterPipeline = [] }: {
    keys: K | K[]
    // eslint-disable-next-line ts/ban-types
    filterPipeline?: Record<K, (filterPipeline | string & {})[] | filterPipeline> | object
  }) => {
    keys = typeof keys === 'string' ? [keys] : keys
    this.set({
      keys,
      queryPipeline: ['contains'],
      filterPipeline,
    })
    return this
  }

  /**
   * @description 时间区间查询 快捷操作
   */
  timeRange = ({ startTimeKey, endTimeKey, searchKey }: {
    startTimeKey: K
    endTimeKey: K
    searchKey: string
  }) => {
    this.set({
      keys: [startTimeKey] as any,
      queryPipeline: ['lte'],
      filterPipeline: { [startTimeKey]: ['ISODate'] },
    })
    this.set({
      keys: [endTimeKey],
      queryPipeline: ['gte'],
      filterPipeline: { [endTimeKey]: ['ISODate'] },
    })
    this.AND({ keys: [startTimeKey, endTimeKey] })
    this.mapKeys({
      searhKeyMap: {
        [startTimeKey]: searchKey,
        [endTimeKey]: searchKey,
      } as any,
    })
    return this
  }

  /**
   * @description 时间区间查询 createAt 快捷操作
   * - 默认值
   * - startTimeKey 'startTime'
   * - endTimeKey 'endTime'
   * - searchKey 'createAt'
   */
  createAtTimeRange = () => {
    this.timeRange({
      startTimeKey: 'startTime' as any,
      endTimeKey: 'endTime' as any,
      searchKey: 'createAt' as any,
    })
    return this
  }

  mapKeys = ({ searhKeyMap }: { searhKeyMap: Partial<Record<K, string>> }) => {
    const { where = {} } = this.query
    const { AND = [], OR = [], NOT = [] } = where
    const arr = [...AND, ...NOT, ...OR]
    Object.keys(searhKeyMap).forEach((oldKey) => {
      const newKey = searhKeyMap[oldKey]
      if (!isEmptyInput(where[oldKey])) {
        where[newKey] = where[oldKey] ?? null
        delete where?.[oldKey]
      }
      // 修改 AND = [], OR = [], NOT = [] 的键
      arr.forEach((item) => {
        if (!isEmptyInput(item[oldKey])) {
          item[newKey] = item[oldKey] ?? null
          delete item?.[oldKey]
        }
      })
    })
    return this
  }

  /**
   * @description 组合参数为and 快捷操作
   */
  AND = ({ keys = [] }: { keys: K[] }) => {
    this.combine({ keys, combine: 'AND' })
    return this
  }

  /**
   * @description 组合参数为or 快捷操作
   */
  OR = ({ keys = [] }: { keys: K[] }) => {
    this.combine({ keys, combine: 'OR' })
    return this
  }

  /**
   * @description 组合参数为not 快捷操作
   */
  NOT = ({ keys = [] }: { keys: K[] }) => {
    this.combine({ keys, combine: 'NOT' })
    return this
  }

  /**
   * @description 组合参数为
   * 组合参数不会被覆盖只会累加
   */
  combine = ({ keys = [], combine = 'AND' }: { keys: K[], combine?: Combine }) => {
    const { where = {} } = this.query
    const { combines, other } = Object.keys(where).reduce((acc, key: any) => {
      if (keys.includes(key)) {
        acc.combines.push({
          [key]: where[key],
        })
      }
      else {
        acc.other[key] = where[key]
      }
      return acc
    }, { combines: [], other: {} })
    const _combine = where[combine] ?? []
    this.query = {
      where: {
        ...other,
        [combine]: [..._combine, ...combines],
      },
    }
    return this
  }

  /**
   * @description 多值查询 OR
   */
  multipleRelationOR = ({ keys = [] }: {
    keys: K | K[] | []
  }) => {
    const { where = {} } = this.query
    const { OR = [] } = where
    keys = typeof keys === 'string' ? [keys] : keys
    const _OR = keys.map((key) => {
      const values = where[key] ?? []
      delete where[key]
      return {
        [key]: {
          some: {
            OR: values,
          },
        },
      }
    })
    this.query = {
      ...this.query,
      where: {
        ...where,
        OR: [
          ...OR,
          ..._OR,
        ],
      },
    }
    return this
  }

  /**
   * @description 多值查询 AND
   */
  multipleAND = ({ keys = [] }: {
    keys: K | K[] | []
  }) => {
    const { where = {} } = this.query
    const { AND = [] } = where
    keys = typeof keys === 'string' ? [keys] : keys
    const _AND = keys.map((key) => {
      const values = where[key] ?? []
      delete where[key]
      return {
        [key]: {
          every: {
            AND: values,
          },
        },
      }
    })
    this.query = {
      ...this.query,
      where: {
        ...where,
        AND: [
          ...AND,
          ..._AND,
        ],
      },
    }
    return this
  }

  /**
   * @description 多值查询 NOT
   */
  multipleNOT = ({ keys = [] }: {
    keys: K | K[] | []
  }) => {
    const { where = {} } = this.query
    const { NOT = [] } = where
    keys = typeof keys === 'string' ? [keys] : keys
    const _NOT = keys.map((key) => {
      const values = where[key] ?? []
      delete where[key]
      return {
        [key]: {
          every: {
            NOT: values,
          },
        },
      }
    })
    this.query = {
      ...this.query,
      where: {
        ...where,
        NOT: [
          ...NOT,
          ..._NOT,
        ],
      },
    }
    return this
  }

  end = () => {
    return this.query.where
  }

  // 以下为filter
  /**
   * @description map filter filterPipeline: ['map|key1,key2']
   * 数组取值, 参数为需要map的键
   */
  map = (source: Record<string, any>[], key: string, keys: any[]) => {
    return source.map(item => keys.reduce((acc, k) => {
      acc[k] = item[k]
      return acc
    }, {}))
  }

  /**
   * @description map filter filterPipeline: ['mapId']
   * 数组取值返回id 无参数
   */
  mapId = (source: Record<string, any>[]) => {
    return source.map(item => item.id, {})
  }

  /**
   * @description map filter filterPipeline: ['mapPickOne|id']
   * 只接受一个参数
   */
  mapPickOne = (source: Record<string, any>[], key: string, keys: any[]) => {
    return source.map(item => item[keys[0]] || null)
  }

  ISODate = (source: string) => {
    return isEmptyInput(source) ? null : new Date(source).toISOString()
  }

  /**
   * @description 将数组单个值转为对象 filterPipeline: ['mapToObj|id']
   */
  mapToObj(source: Record<string, any>[], key: string, keys: any[]) {
    return source.map((item) => {
      return keys.reduce((acc, key) => {
        acc[key] = item
        return acc
      }, {})
    })
  }
}

export type Pipeline = 'lte' | 'gte' | 'lt' | 'gt' | 'contains' | 'endsWith' | 'equals' | 'in' | 'not' | 'notIn' | 'startWith' | 'reassign'
export type filterPipeline = 'map' | 'mapId' | 'mapPickOne' | 'mapToObj'
export type Combine = 'OR' | 'AND' | 'NOT'





import { isArray, isEmptyInput, isPlainObj } from '@/utils'

export class PrismaBuilder<
T,
TableFields = any,
> {
  #query: any = {}
  #source: T
  #createRelation: any = {}
  #create: any = {}

  /**
   * 切换合并模式INNER为正常的合并模式 combine， 剩余模式是合并模式会将值进行合并
   */
  #mode: 'INNER' | 'AND' | 'OR' | 'NOT' | 'CREATE' | 'CREATE_RELATION' = 'INNER'
  constructor(source: T = {} as T, query: Record<string, any> = {}) {
    this.#source = source
    this.#query = query
    return this
  }

  /**
   * @description 时间区间查询
   */
  timeRange = ({ startTimeField, endTimeField, to }: {
    startTimeField: keyof T
    endTimeField: keyof T
    to: keyof Omit<TableFields, 'NOT' | 'OR' | 'AND'>
  }) => {
    const startTimeVal = this.#source[startTimeField]
    const endTimeVal = this.#source[endTimeField]
    const query: Partial<{ ltg: T[keyof T], gte: T[keyof T] }> = {}
    if (!isEmptyInput(startTimeVal))
      query.ltg = startTimeVal

    if (!isEmptyInput(endTimeVal))
      query.gte = endTimeVal

    this.merge({
      [to]: query,
    })
    return this
  }

  /**
   * @description like查询
   * 数组类型的值会join，默认使用”,’拼接，可在自定义
   */
  contains = (
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params: {
      join?: string
      get?: string
      filter?: Filter
    } = {},
  ) => {
    const { join, get, filter } = params
    this.set({
      key,
      join,
      filter,
      get,
      type: 'plainType',
      cb(query, k, val) {
        query[k] = {
          contains: val,
        }
      },

    })
    return this
  }

  /**
   * @description 全等
   */

  equals = (
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params: {
      join?: string
      get?: string
      filter?: Filter
    } = {},
  ) => {
    const { join, get, filter } = params
    this.set({
      key,
      join,
      get,
      type: 'plainType',
      filter,
      cb(query, k, val) {
        query[k] = {
          equals: val,
        }
      },
    })
    return this
  }

  /**
   * @description 赋值,直接赋值，如果key对应的值为对象可配置get进行取值
   */
  assign = <RelationTableFields extends Record<string, any> = Record<string, any>>(
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params: {
      join?: string
      get?: string
      filter?: Filter
      itemGet?: keyof RelationTableFields
      operate?: Operate
    } = {},
  ) => {
    const {
      filter,
      get,
      join,
      itemGet = 'id',
      operate = 'plainType',
    } = params
    this.set({
      filter,
      get,
      itemGet: itemGet as any,
      key,
      join,
      type: operate,
      cb(query, k, val) {
        query[k] = val
      },
    })
    return this
  }

  /**
   * @description 关联查询 some，满足其中一个条件即可
   */
  relationOr<RelationTableFields extends Record<string, any> = Record<string, any>>(
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params: {
      get?: string
      itemGet?: keyof RelationTableFields
      filter?: Filter
    } = {},
  ) {
    const {
      get,
      filter = Number,
      itemGet = 'id',
    } = params
    this.set({
      filter,
      get,
      itemGet,
      key,
      type: 'arrayType',
      cb: (query, k, val) => {
        query[k] = {
          some: {
            [itemGet]: val,
          },
        }
      },
    })
    return this
  }

  /**
   * @description 关联查询 every，满足所有条件
   */
  relationAnd<RelationTableFields extends Record<string, any> = Record<string, any>>(
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params:
    {
      get?: string
      itemGet?: keyof RelationTableFields
      filter?: Filter
    } = {},
  ) {
    const { get, filter = Number, itemGet = 'id' } = params
    this.set({
      filter,
      get,
      itemGet,
      key,
      type: 'arrayType',
      cb: (query, k, val) => {
        query[k] = {
          every: {
            [itemGet]: val,
          },
        }
      },
    })
    return this
  }

  /**
   * @description 关联查询 none，排除所有
   */
  relationNot<RelationTableFields extends Record<string, any> = Record<string, any>>(
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params:
    {
      get?: string
      itemGet?: keyof RelationTableFields
      filter?: Filter
    } = {},
  ) {
    const { get, filter = Number, itemGet = 'id' } = params
    this.set({
      filter,
      get,
      key,
      itemGet,
      type: 'arrayType',
      cb: (query, k, val) => {
        query[k] = {
          none: {
            [itemGet]: val,
          },
        }
      },
    })
    return this
  }

  /**
   *
   * @description in 查询
   */
  in(
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params:
    {
      get?: string
      filter?: Filter
      itemGet?: string
    } = {},
  ) {
    const { get, filter, itemGet = 'id' } = params
    this.set({
      filter,
      get,
      itemGet,
      key,
      type: 'arrayType',
      cb: (query, k, val) => {
        query[k] = {
          in: val,
        }
      },
    })
    return this
  }

  /**
   *
   * @description notIn 查询
   */
  notIn(
    key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>,
    params:
    {
      get?: string
      join?: string
      itemGet?: string
      filter?: Filter
    } = {},
  ) {
    const { get, filter, itemGet = 'id' } = params
    this.set({
      filter,
      get,
      itemGet,
      key,
      type: 'arrayType',
      cb: (query, k, val) => {
        query[k] = {
          notIn: val,
        }
      },
    })
    return this
  }

  /**
   * @description 生成组合条件AND
   */
  ADD(fn: (t: this) => void) {
    this.#mode = 'AND'
    fn(this)
    this.#mode = 'INNER'
    return this
  }

  /**
   * @description 生成组合条件NOT
   */
  NOT(fn: (t: this) => void) {
    this.#mode = 'NOT'
    fn(this)
    this.#mode = 'INNER'
    return this
  }

  /**
   * @description 生成组合条件OR
   */
  OR(fn: (t: this) => void) {
    this.#mode = 'OR'
    fn(this)
    this.#mode = 'INNER'
    return this
  }

  /**
   * @description 获取查询条件
   */
  query() {
    return this.#query
  }

  /**
   * @description 此处定义merge Query的策略
   */
  private mergeQuery(query) {
    const { NOT = [], OR = [], AND = [] } = this.#query
    const has = Reflect.ownKeys(query).length
    switch (this.#mode) {
      case 'INNER':
        this.#query = {
          ...this.#query,
          ...query,
        }
        break
      case 'NOT':
        if (has) {
          this.#query = {
            ...this.#query,
            NOT: [
              ...NOT,
              query,
            ],
          }
        }

        break
      case 'OR':
        if (has) {
          this.#query = {
            ...this.#query,
            OR: [
              ...OR,
              query,
            ],
          }
        }
        break
      case 'AND':
        this.#query = {
          ...this.#query,
          AND: [
            ...AND,
            query,
          ],
        }
        break
      default:
        break
    }
  }

  /**
   * @description 此处定义CreateRelation的策略
   */
  private mergeCreateRelation(query) {
    const { NOT = [], OR = [], AND = [] } = this.#createRelation
    const has = Reflect.ownKeys(query).length
    switch (this.#mode) {
      case 'NOT':
        if (has) {
          this.#createRelation = {
            ...this.#createRelation,
            NOT: [
              ...NOT,
              query,
            ],
          }
        }

        break
      case 'OR':
        if (has) {
          this.#createRelation = {
            ...this.#createRelation,
            OR: [
              ...OR,
              query,
            ],
          }
        }
        break
      case 'AND':
        this.#createRelation = {
          ...this.#createRelation,
          AND: [
            ...AND,
            query,
          ],
        }
        break
      default:
        this.#createRelation = {
          ...this.#createRelation,
          ...query,
        }
        break
    }
  }

  /**
   * @description 此处定义Create merge的策略
   */
  private mergeCreate(query) {
    this.#create = {
      ...this.#create,
      ...query,
    }
  }

  /**
   * @description 此处定义merge的策略
   */
  private merge(query) {
    // 合并创建逻辑
    if (this.#mode === 'CREATE')
      this.mergeCreate(query)

    else if (this.#mode === 'CREATE_RELATION')
      this.mergeCreateRelation(query)

    else
      this.mergeQuery(query)
  }

  /**
   * @description 创建 connect
   */
  createRelation<RelationTableFields extends Record<string, any> = Record<string, any>>(
    params: {
      key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>
      get?: string
      itemGet?: keyof RelationTableFields
      join?: string
      filter?: Filter
    },
    fn: (t: this) => any,
  ) {
    this.#mode = 'CREATE_RELATION'
    const { get, filter = Number, key, itemGet = 'id' } = params ?? {}
    fn(this)
    console.log(this.#createRelation)

    // this.set({
    //   filter,
    //   get,
    //   itemGet,
    //   key,
    //   type: 'arrayType',
    //   cb: (query, k) => {
    //     console.log(this.#createRelation)
    //     query[k] = {
    //       connect: { [itemGet]: this.#createRelation },
    //     }
    //   },
    // })
    return this
  }
  /**
   * @description 生成创建数组 - 时间类型
   */

  createTime(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>, params: { get?: string } = {}) {
    const { get } = params
    this.set({
      key,
      get,
      type: 'dateType',
      cb(query, k, val) {
        query[k] = val
      },
    })
    return this
  }

  set<RelationTableFields extends Record<string, any> = Record<string, any>>(
    params:
    {
      key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>
      get?: string
      filter?: Filter
      join?: string
      itemGet?: keyof RelationTableFields
      type: Operate
      cb: (query: any, k: string, val: any) => void
    },
  ) {
    const {
      join,
      cb,
      filter,
      get,
      itemGet,
      key,
      type,
    } = params ?? {}
    const {
      keys,
      isObj,
      query,
    } = this.keys(key)
    const finalKeys = keys || key
    finalKeys.forEach((k) => {
      const val = this.#source[k]
      this[type]({
        val,
        filter,
        itemGet: itemGet as any,
        get,
        join,
        k,
        isObj,
        key,
        cb: (...args) => {
          cb(query, ...args)
        },
      },
      )
    })
    this.merge(query)
    return this
  }

  /**
   * @description 创建create data,不要用于查询条件的构建, 回调函数中只能用create打头的函数
   */
  create(fn: (t: this) => void) {
    this.#mode = 'CREATE'
    if (Reflect.ownKeys(this.#query).length)
      throw new Error('不可以在创建查询时使用create！')

    fn(this)
    this.#mode = 'INNER'
    return this.#create
  }

  private keys(key: keyof T | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>) {
    let keys = null
    const query: Partial<Record<keyof T, { every: { in: any } } >> = {}
    if (typeof key === 'string')
      keys = [key]

    const isObj = isPlainObj(key)
    if (isObj)
      keys = Object.keys(key)

    return { keys, isObj, query }
  }

  /**
   * arrayType 不支持join
   */
  private arrayType<RelationTableFields extends Record<string, any> = Record<string, any>>(
    params: {
      val: any
      filter: NumberConstructor | StringConstructor | BooleanConstructor
      get: keyof RelationTableFields
      k: any
      isObj: boolean
      itemGet: string
      key: string | number | symbol | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>
      cb: (k: string, val: any) => void
    },
  ) {
    let {
      val,
      filter,
      get,
      itemGet = 'id',
      isObj,
      k,
      key,
      cb,
    } = params ?? {}
    val = isEmptyInput(get) ? val : val?.[get]
    if (!isEmptyInput(val) && val.length) {
      if (typeof val === 'string') {
        val = val.split(',').map(id => filter ? filter(id) : id).filter(v => !isEmptyInput(v))
      }
      else if (isPlainObj(val[0])) {
        // 值为对象
        val = val.map(item => filter ? filter(item[itemGet]) : item[itemGet]).filter(v => !isEmptyInput(v))
      }
      else {
        val = val.map(id => filter ? filter(id) : id).filter(v => !isEmptyInput(v))
      }
      k = isObj ? key[k] : k
      cb(k, val)
    }
  }

  /**
   * 处理原始类型的值， 如果是数组会拼接， 对象需要指定joinOrGetKey来取值
   */
  private plainType(
    params: {
      val: any
      k: any
      isObj: boolean
      join: string
      get: string
      itemGet: string
      filter: Filter
      key: string | number | symbol | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>
      cb: (k: string, val: any) => void
    },
  ) {
    let {
      val,
      join = ',',
      get,
      cb,
      isObj,
      k,
      key,
      itemGet,
      filter,
    } = params ?? {}
    val = isEmptyInput(get) ? val : val?.[get]
    if (!isEmptyInput(val)) {
    // 对象数组
      if (isArray(val) && isPlainObj(val[0])) {
        val = val.map(item => filter ? filter(item[itemGet]) : item[itemGet]).filter(v => !isEmptyInput(v)).join(join)
      }
      if (filter) {
        val = filter(val)
      }
      k = isObj ? key[k] : k
      cb(k, val)
    }
  }

  /**
   * 处理时间类型的值转为ISO
   */
  private dateType(
    params: {
      val: any
      k: any
      isObj: boolean
      key: string | number | symbol | (keyof T)[] | Partial<Record<keyof T, keyof TableFields>>
      get: string
      cb: (k: string, val: any) => void
    },
  ) {
    let {
      val,
      cb,
      isObj,
      k,
      key,
      get,
    } = params ?? {}
    k = isObj ? key[k] : k
    val = isEmptyInput(get) ? val : val?.[get]
    if (!isEmptyInput(val)) {
      val = new Date(val).toISOString()
      cb(k, val)
    }
  }
}
export type Operate = 'arrayType' | 'plainType' | 'dateType'
export type Filter = BooleanConstructor | StringConstructor | NumberConstructor | null
